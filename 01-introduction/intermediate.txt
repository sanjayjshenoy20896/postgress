primary key:
A key that is used to uniquely identify a record.

Understanding primary keys:
In the absence of primary key, there will not be a way to uniquely identify a row by a fields


Removing the primary key constraint:
ALTER TABLE person  DROP CONSTRAINT person_pkey;

ALTER TABLE person ADD PRIMARY KEY (id);

unique constraints:
select email ,count(*) FROM person GROUP BY email HAVING COUNT(*) > 1;
It is used to have unique values for  a column.

to add a constraint:
Option 1
syntax:
ALTER TABLE <table_name> ADD CONSTRAINT <constraint_name> UNIQUE(<list of unique column_name>)
eg:
ALTER TABLE person ADD CONSTRAINT unique_email_address UNIQUE (email);

Option 2 -> allows postgres to name the constraint
SYNTAX
ALTER TABLE person ADD UNIQUE (email);


to remove a unique constraint:
ALTER TABLE person DROP CONSTRAINT unique_email_address;


Check constraint:
It is used to check the value to be from list of allowed values or pre defined values
SYNTAX:
ALTER TABLE <table_name> ADD CONSTRAINT <constraint_name> CHECK (<define the constraint to check>)
eg:
ALTER TABLE person ADD CONSTRAINT gender_constarint CHECK(gender = "Male" OR gender = "Female");

DELETE or UPDATE records:
The below command is dangerous -> DELETE FROM person; 
It will delete all rows from tables

DELETE RECORDS:
Syntax:
DELETE FROM person <condition/filter>
eg:
DELETE FROM person WHERE id = 1;

UPDATE RECORDS:
Syntax
UPDATE table_name
SET <column_name> = <column_value>   -> add multiple columns sep by comma(,)
<condition>

eg:
UPDATE person SET email = 'gasper.walters@gnail.com' WHERE first_name = 'Gasper' AND last_name = 'Walters';

Conflict do nothing: (duplciate key errors or exceptions)
INSERT INTO person (id,first_name,last_name,gender,email,date_of_birth,country_of_birth) VALUES ('914','Aguste','Brounsell','Male',' abrounsellr7@ox.ac.uk', DATE '2025-05-25','Malaysia') ON CONFLICT (id) DO NOTHING;

This is used to handle errors by performing no operation in case of constraint conflict duting insert / update

Upsert:
INSERT INTO person (id,first_name,last_name,gender,email,date_of_birth,country_of_birth) VALUES ('914','Aguste','Brounsell','Male',' abrounsellr7@ox.ac.uk', DATE '2025-05-25','Malaysia') ON CONFLICT (email) DO UPDATE SET email = EXCLUDED.email;

Above command will not create but it will update the column_name mentioned. This is mainly used in distributed systems.



Serial and sequences:
BIGSERIAL -> special datatype that auto increments (This is actually a big int with a autoincrement feature);
The sequence is stored in a special key called car_id_seq.


 SELECT * FROM person_id_seq; -> it will give the last sequence value.

 select nextval('person_id_seq'::regclass); -> this function actually incremnts the sequence id;

Sequences are basically BIGINT. Whose future value is stored in sequence value.

How to restart the sequence:
Syntax:
ALTER SEQUENCE <sequence_name> RESTART WITH <NUMBER>;
Eg:
ALTER SEQUENCE person_id_seq RESTART WITH 9;


Extensions:
They are used for adding additional functionality to our existing databases.

Generate universally unique identifiers (UUIDs)
Generate unique identifier for the field in the table.
A universally unique identifier (UUID) is a 128-bit number designed to be a unique identifier for objects in computer systems.
Collison is impossible.

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" ;
eg: 923ef1e9-b8b4-4010-bd3a-1da3949145e7

UUID as primary keys:
Using the extension, we are able to perform this operation.


During joins if the primary key and foreign key in individual table is same. we could join using field name
INNER JOIN:
Previous query:
this is the safe way
SELECT * FROM person JOIN car ON car.car_uid = person.car_uid;
updated query:
SELECT * FROM person JOIN car USING (car_uid);

LEFT JOIN:
this is the safe way
Previous  query:
SELECT * FROM person LEFT JOIN car ON car.car_uid = person.car_uid;
updated Query:
SELECT * FROM person LEFT JOIN car USING (car_uid);

